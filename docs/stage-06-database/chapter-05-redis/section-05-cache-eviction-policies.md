# 6.5.5 缓存淘汰策略 (Cache Eviction Policies)

## 概述

Redis 是一个基于内存的数据库，这意味着它的存储容量受到服务器物理内存的限制。我们可以通过 Redis 配置文件 `redis.conf` 中的 `maxmemory` 指令来设定其最大可使用的内存量。

那么，当 Redis 的内存使用达到 `maxmemory` 上限时，如果此时客户端再请求写入新的数据，会发生什么呢？

为了应对这种情况，Redis 提供了一套**缓存淘汰策略 (Eviction Policies)**。这套策略定义了当内存不足时，Redis应该按照何种规则来删除一部分旧数据，从而为新数据腾出空间。

## 什么是淘汰策略？

淘汰策略是在内存受限的情况下，决定“牺牲”哪些键(key)的算法。通过在 `redis.conf` 中配置 `maxmemory-policy` 指令，我们可以告诉 Redis 在遇到内存瓶颈时应该采取哪种行动。

如果不进行任何配置，Redis 默认的策略是 `noeviction`，即不淘汰任何数据，而是对所有可能导致内存增加的写命令返回错误。

## Redis 的淘汰策略

Redis 提供了多种淘汰策略，它们大致可以分为两类：**从设置了过期时间的键中淘汰**，和**从所有键中淘汰**。

### 1. 从设置了过期时间的键中进行淘汰

这类策略只会考虑那些已经使用 `EXPIRE` 等命令设置了 TTL (Time-To-Live) 的键。

-   **`volatile-lru`**: **L**east **R**ecently **U**sed (最近最少使用)。在设置了过期时间的键中，移除最近最久未被访问的键。
-   **`volatile-lfu`**: **L**east **F**requently **U**sed (最不经常使用)。在设置了过期时间的键中，移除被访问次数最少的键。 (Redis 4.0+ 新增)
-   **`volatile-ttl`**: 在设置了过期时间的键中，移除剩余存活时间 (TTL) 最短的键。
-   **`volatile-random`**: 在设置了过期时间的键中，随机移除一个键。

### 2. 从所有键中进行淘汰

这类策略会考虑数据库中的所有键，无论它们是否设置了过期时间。

-   **`allkeys-lru`**: 在**所有键**中，移除最近最久未被访问的键。**这是作为纯缓存时最常用的策略之一**。
-   **`allkeys-lfu`**: 在**所有键**中，移除被访问次数最少的键。 (Redis 4.0+ 新增)
-   **`allkeys-random`**: 在**所有键**中，随机移除一个键。

### 3. 不淘汰

-   **`noeviction`**: **(默认策略)** 不淘汰任何键。当内存达到上限时，所有会导致内存增加的写命令（如 `SET`, `LPUSH` 等）都会返回错误，而读命令不受影响。

## LRU vs. LFU

`lru` 和 `lfu` 是最常用也最智能的两种策略，理解它们的区别很重要。

-   **LRU (最近最少使用)**
    -   **关注点**：键**最后一次被访问的时间**。
    -   **工作方式**：它会淘汰掉最长时间没有被访问过的键。
    -   **潜在问题**：如果一个曾经的热点数据（被访问了百万次）在一段时间内没有被访问，它可能会被一个刚刚被偶然访问到的冷门数据所淘汰。它无法很好地保护真正的“热点”数据。

-   **LFU (最不经常使用)**
    -   **关注点**：键在一段时间内**被访问的频率**。
    -   **工作方式**：它会淘汰掉被访问次数最少的键。它不仅记录了访问次数，还会考虑访问时间的衰减。
    -   **优势**：能够更好地保留那些持续热门的数据，即使它们偶尔没有被访问。它能更准确地反映一个键的“热度”。

**注意**：为了节省内存，Redis 实现的 LRU 和 LFU 都是一种**近似算法**，而不是精确的实现。它通过对少量键进行采样来估算出最应该被淘汰的键，但在绝大多数场景下，这种近似已经足够好了。

## 如何选择合适的策略？

选择哪种策略，完全取决于你的业务场景和 Redis 的用途。

| 策略                | 推荐使用场景                                                                                              |
|:--------------------|:----------------------------------------------------------------------------------------------------------|
| **`allkeys-lru`**   | 当你将 Redis **纯粹用作缓存**时，这是一个非常好的通用选择。它保留了最近被访问的热点数据。             |
| **`allkeys-lfu`**   | 同样用于纯缓存场景。如果你的应用数据访问模式符合“二八定律”（即少数热点数据贡献了绝大部分访问量），`lfu` 通常比 `lru` 效果更好。 |
| **`volatile-lru/lfu`** | 当你将 Redis 用于**混合目的**：一部分键作为缓存（设置了 TTL），另一部分键作为需要持久化的数据（没有设置 TTL）。这种策略可以确保你持久化的键不会因为缓存空间不足而被意外删除。 |
| **`volatile-ttl`**  | 适用于那些你希望尽快清除即将过期数据的场景，不太常用。                                                    |
| **`noeviction`**    | 当你将 Redis 作为**主数据库**或**高可靠性的存储**（如分布式锁）来使用时，这是唯一安全的选择。它保证了任何数据都不会被意外删除，你需要通过监控内存并手动扩展来管理容量。 |
| `*-random`          | 在数据访问没有明显热点，呈均匀分布时可以考虑。性能消耗最小，但效果也最不智能。                            |

## 如何配置

**1. 通过配置文件 (`redis.conf`)**
这是最常用的方式。找到或添加以下两行：
```conf
# 设置最大使用内存为 2GB
maxmemory 2gb

# 设置淘汰策略为 allkeys-lru
maxmemory-policy allkeys-lru
```
修改后需要重启 Redis 服务。

**2. 通过命令行动态修改**
你可以通过 `CONFIG SET` 命令在 Redis 运行时动态地修改淘汰策略。
```bash
# 连接到 redis
redis-cli

# 查看当前策略
CONFIG GET maxmemory-policy

# 设置新策略
CONFIG SET maxmemory-policy allkeys-lfu
```

---

## 练习任务

1.  **查找配置**：
    找到你的 Redis 安装目录或 Docker 容器中的 `redis.conf` 默认配置文件。打开它，查找 `maxmemory` 和 `maxmemory-policy` 这两个指令，看看它们的默认值是什么。

2.  **测试 `noeviction`**：
    使用 `CONFIG SET` 命令，将你的 Redis 实例最大内存设置为一个极小的值（如 `1mb`），并将淘汰策略设置为 `noeviction`。然后尝试不断地用 `SET` 命令写入数据，直到写不进去为止。观察 Redis 返回的是什么错误。

3.  **场景选择**：
    分析以下三个场景，并为它们选择最合适的缓存淘汰策略，并说明理由：
    -   **场景 A**：一个图片托管网站，使用 Redis 缓存热门图片的元数据。有些图片常年热门，有些则是短期内被大量访问。
    -   **场景 B**：一个后台任务系统，使用 Redis 的 List 作为消息队列，同时使用 Redis 的 Hash 存储一些系统配置信息。不希望配置信息被删除。
    -   **场景 C**：一个科学计算应用，使用 Redis 临时存储大量中间计算结果，这些结果重要性均等，且很快会被处理掉。
