# 6.5.4 缓存问题：穿透、击穿与雪崩

## 概述

虽然缓存是提升系统性能的利器，但它也引入了新的复杂性和潜在的故障点。如果对缓存使用不当，在某些特定场景下，缓存系统可能会失效，导致所有请求直接打向数据库，从而引发数据库过载甚至宕机。

本节将深入探讨缓存架构中最经典的三个问题：**缓存穿透、缓存击穿和缓存雪崩**，并详细介绍它们的成因及主流的解决方案。

## 1. 缓存穿透 (Cache Penetration)

-   **定义**：指客户端请求查询一个**在缓存中和数据库中都完全不存在**的数据。
-   **导致后果**：由于缓存中没有，请求每次都会直接穿透到数据库层进行查询，而数据库也查无此物。如果这类请求量很大（例如，来自恶意攻击），就会给数据库带来巨大的、不必要的压力。
-   **生活类比**：一个恶意用户，用图书馆里根本不存在的书名，一遍又一遍地去为难图书管理员。管理员每次都得去仓库翻个底朝天，然后无奈地告诉用户“这本书没有”。

### 解决方案

#### a) 缓存空对象 (Cache Null Objects)

-   **思路**：当数据库查询返回为空时，我们仍然在缓存中为这个键存储一个特殊的值（例如一个空字符串 `""` 或 `"null"`），但为其设置一个**较短的过期时间**（如 1-5 分钟）。
-   **优点**：实现简单，效果显著。
-   **缺点**：会占用少量缓存空间来存储这些“空对象”。
-   **示例代码**：
    ```php
    function getUserById(int $userId): ?array
    {
        // ...
        $cacheKey = "user:{$userId}";
        $cachedData = $redis->get($cacheKey);

        if ($cachedData !== null) {
            // 如果缓存的是我们定义的空值，直接返回 null
            return $cachedData === "null_placeholder" ? null : json_decode($cachedData, true);
        }

        $user = $db->query("SELECT ... WHERE id = {$userId}");

        if ($user) {
            $redis->setex($cacheKey, 3600, json_encode($user));
        } else {
            // 关键：数据库中不存在，缓存一个空对象，并设置较短的 TTL
            $redis->setex($cacheKey, 300, "null_placeholder"); 
        }
        return $user;
    }
    ```

#### b) 布隆过滤器 (Bloom Filter)

-   **思路**：这是一种更高级的、用于前置拦截的方案。布隆过滤器是一个空间效率极高的概率型数据结构，它可以用来判断一个元素**是否可能存在**于一个集合中。
    -   当它说“**这个 key 肯定不存在**”时，那就真的不存在。
    -   当它说“**这个 key 可能存在**”时，它实际可能不存在（有一定的误判率）。
-   **流程**：
    1.  将所有可能存在的 key（例如，数据库中所有的 `user_id`）预先加载到一个布隆过滤器中。
    2.  当一个读请求到来时，先去布隆过滤器查询这个 key 是否存在。
    3.  如果布隆过滤器判断不存在，则直接拒绝请求，根本不会去查询缓存和数据库。
-   **优点**：从源头拦截了大量非法请求，效率极高。
-   **缺点**：实现相对复杂，存在误判率，且不支持删除元素。

## 2. 缓存击穿 (Cache Breakdown)

-   **定义**：指一个**热点数据 (Hot Key)**（即访问量极高的键），在它**过期失效的瞬间**，有大量的并发请求同时涌入，这些请求都会击穿缓存，直接打到数据库上，导致数据库压力剧增。
-   **与穿透的区别**：击穿的对象是**数据库中真实存在**的数据，只是缓存过期了。
-   **生活类比**：在双十一零点，所有用户都在抢购同一件爆款商品。零点时，该商品的缓存正好过期，成千上万的请求瞬间全部打到了数据库上。

### 解决方案

#### a) 互斥锁 (Mutex Lock)

-   **思路**：在缓存未命中的情况下，不是所有请求都去查数据库，而是让它们竞争一个“锁”。只有拿到锁的**第一个请求**才有资格去查询数据库、重建缓存。其他请求则要么等待，要么直接返回一个友好的提示。
-   **实现**：可以使用 Redis 的 `SETNX` (SET if Not eXists) 命令来实现一个简单的分布式锁。
-   **流程**：
    1.  缓存未命中。
    2.  尝试使用 `SETNX` 设置一个锁键（例如 `lock:user:101`）。
    3.  如果设置成功，说明获得了锁。则去查询数据库，重建缓存，最后用 `DEL` 释放锁。
    4.  如果设置失败，说明锁已被其他线程持有。则可以 `sleep` 一小段时间后重试查询**缓存**（而不是数据库），或者直接返回。
-   **优点**：严格保证了数据一致性，只让一个请求重建缓存，有效防止了“狗扑效应”。
-   **缺点**：实现相对复杂，未获取到锁的线程需要等待，增加了响应时间。

#### b) “永不”过期（逻辑过期）

-   **思路**：从应用层面来看，缓存中的数据永远不会真正过期。我们不在 Redis 中设置 TTL，而是在存储的值中包含一个**逻辑上的过期时间**字段。
-   **流程**：
    1.  读请求发现缓存命中。
    2.  检查值中的逻辑过期时间是否已到。
    3.  **如果未过期**：直接返回数据。
    4.  **如果已过期**：
        -   尝试获取一个**异步更新锁**。
        -   **如果获取成功**：开启一个后台线程或任务，去异步地重建缓存。
        -   **无论是否获取成功**：**立即将当前这份旧的（过期的）数据返回给用户**。
-   **优点**：用户请求的响应时间几乎不受影响，没有线程需要等待。
-   **缺点**：在缓存重建期间，用户会短暂地获取到旧数据，对数据一致性要求极高的场景不适用。

## 3. 缓存雪崩 (Cache Avalanche)

-   **定义**：指在某一瞬间，**大量的缓存键同时大面积失效**（例如，同时过期），或者 **Redis 服务器自身宕机**，导致海量的请求在同一时间直接涌向数据库，如同雪崩一样，可能瞬间压垮数据库。
-   **与击穿的区别**：击穿是“一个”热点 key 失效，而雪崩是“一大片” key 失效。
-   **生活类比**：一个城市的所有门禁卡在午夜零点同时失效，第二天早上所有人都被堵在了小区门口，系统陷入瘫痪。

### 解决方案

#### a) 针对“大量 key 同时过期”

-   **核心思路**：让 key 的过期时间变得分散。
-   **方法：设置随机过期时间**：在基础的过期时间上，增加一个随机值。例如，原本统一设置为 1 小时过期，现在改为 `3600 + rand(1, 600)` 秒。这样就把过期时间分散在一个 10 分钟的窗口内，避免了同时失效。

#### b) 针对“Redis 宕机”

-   **核心思路**：提高缓存系统自身的可用性，并做好降级预案。
-   **方法一：搭建高可用集群**：使用 **Redis Sentinel (哨兵)** 或 **Redis Cluster (集群)** 模式。当主节点宕机时，可以自动进行主从切换，保证缓存服务在短时间内恢复。
-   **方法二：服务熔断与降级**：在应用程序中加入熔断机制。当检测到 Redis 无法连接或响应超时时，可以暂时“熔断”对缓存的访问，直接调用后备方案（例如，读取一个本地的静态缓存，或者对于非核心数据直接返回空），而不是把所有压力都传导给数据库。
-   **方法三：数据预热**：在系统启动时，提前将一些热点数据加载到缓存中，避免系统启动初期的大量缓存未命中。

---

## 总结

| 问题       | 定义                                           | 核心原因                         | 解决方案                                           |
|:-----------|:-----------------------------------------------|:---------------------------------|:---------------------------------------------------|
| **缓存穿透** | 查询不存在的数据，导致请求永远穿透缓存。       | 恶意攻击、非法参数               | 缓存空对象、布隆过滤器                             |
| **缓存击穿** | 单个热点 Key 过期，大量并发请求击穿缓存。        | 热点 Key 过期                    | 互斥锁、逻辑过期                                   |
| **缓存雪崩** | 大量 Key 同时过期，或 Redis 宕机。             | Key 集中过期、Redis 故障         | 随机化 TTL、高可用集群、服务降级                 |

---

## 练习任务

1.  **实现缓存空对象**：
    修改上一节 `getUserById` 函数的实现。当从数据库中查询不到用户时，在 Redis 中缓存一个特殊的字符串（如 `EMPTY`），并设置 60 秒的过期时间。再次请求同一个不存在的 ID 时，函数应直接从缓存中判断并返回 `null`，而不会查询数据库。

2.  **分析业务场景**：
    在一个电商秒杀活动开始前，运营人员会把活动商品的信息预热到缓存中，并统一设置了 2 小时的过期时间。请问这最有可能引发上述哪一种缓存问题？你应该向运营人员提出什么建议来优化这个设置？

3.  **设计降级方案**：
    假设你的 `RedisConnection` 类在连接失败时会抛出异常。请修改你的业务代码（如 `getUserById`），增加一个 `try...catch` 块。当捕获到 Redis 连接异常时，函数应该放弃缓存逻辑，直接去查询数据库并返回结果，同时记录一条错误日志，说明“缓存服务不可用，已执行降级策略”。
