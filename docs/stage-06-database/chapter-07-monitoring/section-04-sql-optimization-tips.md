# 6.7.4 常见 SQL 优化技巧

## 概述

在通过慢查询日志和 `EXPLAIN` 定位到性能瓶颈之后，下一步就是着手进行优化。SQL 优化是一个广阔而深入的领域，但对于开发者来说，掌握一些常见且高效的优化技巧，已经能解决 80% 以上的性能问题。

本节将介绍一些立竿见影的 SQL 优化技巧，它们主要围绕**索引优化**和**查询编写**两个方面。

**优化的第一原则：先测量，再优化！** 永远不要凭感觉去优化。始终使用 `EXPLAIN` 和性能指标来指导你的优化工作，并在优化后进行验证。

---

## 1. 索引相关优化

### a) 优化查询的“黄金法则”：为查询条件建立合适的索引

这是最基本也是最重要的一条规则。确保你的 `WHERE` 子句、`JOIN` 的 `ON` 子句，以及 `ORDER BY` 和 `GROUP BY` 中用到的列，都已经被包含在合适的索引中。

### b) 使用覆盖索引 (Covering Index)

-   **是什么**：一个索引包含了查询所需的所有列。这样，MySQL 只需读取索引文件，而无需访问实际的数据行（这个过程称为“回表”），从而极大地提升性能。
-   **如何判断**：当 `EXPLAIN` 结果的 `Extra` 列显示 `Using index` 时，就表示成功使用了覆盖索引。
-   **示例**：
    -   查询：`SELECT user_id, status FROM orders WHERE created_at > '2026-01-01';`
    -   **低效索引**：`INDEX(created_at)`。MySQL 通过此索引找到行，但还需回表去读取 `user_id` 和 `status`。
    -   **高效的覆盖索引**：`INDEX(created_at, user_id, status)`。MySQL 只需扫描这个索引，就能获取所有需要的数据。

### c) 优化复合索引的列顺序

-   **最左前缀原则**：一个复合索引 `(col1, col2, col3)`，可以被 `(col1)`, `(col1, col2)`, `(col1, col2, col3)` 的查询条件利用。
-   **选择性原则**：在创建复合索引时，应将**区分度最高**（即唯一值最多的）的列放在最左边。例如，对于 `WHERE city = '...' AND name = '...'`，`name` 的唯一值远多于 `city`，因此 `INDEX(name, city)` 通常比 `INDEX(city, name)` 要好。

### d) 避免冗余和重复的索引

-   如果已经有了 `INDEX(a, b)`，那么再创建一个 `INDEX(a)` 就是冗余的。
-   过多的索引会占用磁盘空间，并严重拖慢 `INSERT`, `UPDATE`, `DELETE` 等写操作的速度，因为每次写操作都需要维护所有相关的索引。定期审查并删除不用的索引。

---

## 2. 查询编写优化

### a) 避免 `SELECT *`

-   **原因**：
    1.  **增加网络开销**：传输不必要的数据会浪费网络带宽。
    2.  **消耗更多内存**：应用层需要为这些不需要的数据分配内存。
    3.  **无法使用覆盖索引**：`SELECT *` 几乎杜绝了使用覆盖索引的可能性，总会导致回表。
-   **建议**：明确地列出你需要的每一个字段。`SELECT id, username, email FROM users ...`。

### b) 小心使用 `OR` 和 `IN`

-   对于 `OR`，如果 `OR` 连接的条件涉及不同的列，MySQL 可能无法有效利用索引。在某些情况下，使用 `UNION ALL` 来代替 `OR` 可能会得到更好的执行计划。
-   对于 `IN`，当列表中的值非常多时（成百上千），其性能可能会下降。如果 `IN` 列表来自另一个查询，使用 `JOIN` 通常是更好的选择。

### c) 避免在 `WHERE` 子句中对字段使用函数

-   在索引列上使用函数，几乎总会导致索引失效。
-   **反例**：`WHERE DATE(created_at) = '2026-01-10'`。这会让 `created_at` 上的索引作废。
-   **正例**：将计算逻辑移到查询条件的值上。
    `WHERE created_at >= '2026-01-10 00:00:00' AND created_at < '2026-01-11 00:00:00'`。

### d) 优化 `LIMIT` 分页

-   当使用 `LIMIT offset, count` 进行深分页时（即 `offset` 非常大），性能会急剧下降。例如 `LIMIT 1000000, 20`，MySQL 仍然需要扫描并丢弃前 100 万条记录。
-   **优化方法：延迟关联或书签分页 (Keyset Pagination)**
    -   思路：不使用 `offset`，而是利用上一页最后一条记录的 ID（或其他有序且唯一的列）来进行下一次查询。
    -   **旧方法**: `SELECT * FROM posts ORDER BY id LIMIT 1000000, 20;`
    -   **新方法**:
        1.  先快速地在索引上定位到需要的 ID。
        2.  再 `JOIN` 回原表获取数据。
        `SELECT p.* FROM posts p JOIN (SELECT id FROM posts ORDER BY id LIMIT 1000000, 20) AS t ON p.id = t.id;`
    -   **更好的方法（书签法）**：
        `SELECT * FROM posts WHERE id > [上一页最后一条的ID] ORDER BY id LIMIT 20;`

### e) 减少 `JOIN` 的使用

-   每增加一个 `JOIN`，查询的复杂度就会增加，优化器需要考虑的执行计划也会呈指数级增长。
-   确保所有用于 `JOIN` 的列（`ON` 子句中的列）都已经被正确地索引。
-   在某些情况下，将一个复杂的大 `JOIN` 查询，拆分成多个简单的独立查询，然后在应用层进行数据组装，可能会比单个复杂查询更快。

---

## 3. SQL 优化检查清单

当你拿到一条慢查询时，可以对照以下清单进行排查：
1.  [ ] **是否已 `EXPLAIN`**？这是一切的前提。
2.  [ ] **`type` 是否为 `ALL`**？如果是，几乎肯定需要加索引。
3.  [ ] **`key` 是否为 `NULL`**？如果是，检查 `WHERE`/`JOIN` 条件列是否有索引，或者写法是否导致索引失效。
4.  [ ] **`rows` 的值是否过大**？与实际返回的行数相比是否合理？
5.  [ ] **`Extra` 中是否有 `Using filesort` 或 `Using temporary`**？如果有，检查 `ORDER BY` / `GROUP BY` 的列是否有索引。
6.  [ ] **是否使用了 `SELECT *`**？能否只选择需要的列？
7.  [ ] **`WHERE` 子句中的列是否被函数包裹**？
8.  [ ] **`JOIN` 的关联字段是否都有索引**？

---

## 练习任务

1.  **覆盖索引实践**：
    对于你的 `posts` 表，假设有一个常见查询是获取指定用户 (`user_id`) 的所有文章标题 (`title`)。请为这个查询设计一个最高效的覆盖索引，并写出 `CREATE INDEX` 语句。然后用 `EXPLAIN` 验证你的索引是否生效（`Extra` 列是否包含 `Using index`）。

2.  **重写函数查询**：
    假设 `orders` 表中有一个 `order_date` (`DATETIME` 类型) 字段。现在要查询所有在 2025 年 12 月份下的订单。
    -   请写出一个**低效**的、在 `WHERE` 子句中使用了函数的查询。
    -   然后，写出一个**高效**的、能够利用索引的等价查询。

3.  **分页优化思考**：
    在你的 `users` 表中，假设有 100 万用户。你需要实现一个分页功能，显示第 5000 页，每页 20 个用户，按 `id` 排序。请分别写出使用 `OFFSET` 和使用“书签法”的 SQL 查询语句。
