# 6.3.3 锁机制：悲观锁 (Locking Mechanism: Pessimistic Locking)

## 概述

**悲观锁 (Pessimistic Locking)** 是一种并发控制策略。顾名思义，它对数据冲突持“悲观”态度，即它**假设并发冲突很可能会发生**。因此，为了保证数据的绝对一致性，它会在**对数据进行任何操作之前，先将数据锁定**，直到事务完成并释放锁，其他事务才能访问该数据。

这种策略可以用一句话来概括：“先锁后做”。这就像进入一个房间前，先从外面把门锁上，以防止任何人在你使用房间时进来打扰。

悲观锁通常适用于**写多读少**、**数据竞争激烈**的场景，例如秒杀系统中的库存扣减、金融交易中的账户余额修改等，因为在这些场景下，保证数据不出错是第一要务。

## 悲观锁的类型 (InnoDB 行级锁)

在 InnoDB 中，悲观锁主要通过两种行级锁（Row-Level Locks）来实现。行级锁的优点是锁定粒度小，只锁定需要修改的行，而不是整张表，从而可以支持更高的并发度。

### 1. 共享锁 (Shared Lock / S-Lock)

-   **别名**：读锁。
-   **规则**：多个事务可以同时持有同一行数据的共享锁。当一个事务持有 S 锁时，其他事务可以继续对该行数据加 S 锁并进行**读取**，但任何事务都不能对该行数据加排他锁（X-Lock）进行**修改**。
-   **一句话总结**：“大家都可以读，但谁也别想改。”
-   **SQL 语法**：
    -   MySQL 8.0+ & MariaDB: `SELECT ... FOR SHARE`
    -   MySQL 5.7 及更早版本: `SELECT ... LOCK IN SHARE MODE`

### 2. 排他锁 (Exclusive Lock / X-Lock)

-   **别名**：写锁。
-   **规则**：在任何时候，只有一个事务能持有某一行数据的排他锁。当一个事务持有 X 锁时，其他任何事务都不能再对该行数据施加任何类型的锁（无论是 S 锁还是 X 锁），既不能读也不能写。
-   **一句话总结**：“我正在改，谁也别碰。”
-   **SQL 语法**：`SELECT ... FOR UPDATE`

## 如何在 PDO 中使用悲观锁

悲观锁最经典的应用场景是解决“**更新丢失 (Lost Update)**”问题。

#### 问题场景：库存扣减

假设有两个并发请求同时购买同一件商品，该商品的当前库存为 1。

1.  事务 A 读取库存，得到 `stock = 1`。
2.  与此同时，事务 B 也读取库存，同样得到 `stock = 1`。
3.  事务 A 在其应用程序逻辑中判断库存充足，执行 `UPDATE products SET stock = 0`，并提交。
4.  事务 B 也在其逻辑中判断库存充足（因为它读到的也是 1），执行 `UPDATE products SET stock = 0`，并提交。
5.  **最终结果**：卖出了两件商品，但库存只减少了 1。一件商品的销售利润凭空消失了，这就是“更新丢失”。

#### 解决方案：使用 `SELECT ... FOR UPDATE`

我们可以通过在读取库存时加排他锁来解决这个问题。

**PHP + PDO 实现**:
```php
<?php
// ... $pdo 连接对象

$productId = 101; // 假设要购买的商品ID
$quantityToBuy = 1;

try {
    // 1. 开始事务
    $pdo->beginTransaction();

    // 2. 查询库存并施加排他锁 (当前读)
    // 这一步是关键！执行后，该行数据被锁定，其他事务必须等待
    $stmt = $pdo->prepare("SELECT stock FROM products WHERE id = :id FOR UPDATE");
    $stmt->execute([':id' => $productId]);
    $product = $stmt->fetch();

    if (!$product) {
        throw new \Exception("商品不存在！");
    }

    $currentStock = (int)$product['stock'];
    
    // 3. 在业务逻辑中检查库存
    if ($currentStock >= $quantityToBuy) {
        // 4. 库存充足，执行更新
        $newStock = $currentStock - $quantityToBuy;
        $stmtUpdate = $pdo->prepare("UPDATE products SET stock = :stock WHERE id = :id");
        $stmtUpdate->execute([':stock' => $newStock, ':id' => $productId]);
        
        echo "购买成功！\n";
    } else {
        throw new \Exception("库存不足！");
    }

    // 5. 提交事务，释放锁
    $pdo->commit();

} catch (\Exception $e) {
    // 如果发生任何错误（如库存不足、数据库异常），回滚事务
    if ($pdo->inTransaction()) {
        $pdo->rollBack();
    }
    echo "操作失败: " . $e->getMessage() . "\n";
}
```

**加锁后的执行流程**：
1.  事务 A 执行 `SELECT ... FOR UPDATE`，成功获取到 `stock=1` 并对该行数据加上了 X-Lock。 
2.  事务 B 尝试执行 `SELECT ... FOR UPDATE`，但由于该行已被事务 A 锁定，事务 B 的查询会被**阻塞**，进入等待状态。
3.  事务 A 判断库存充足，执行 `UPDATE` 将 `stock` 改为 0，然后 `COMMIT`。**事务一提交，锁就被释放了**。
4.  事务 B 此时解除了阻塞，它的 `SELECT ... FOR UPDATE` 终于可以执行了。它读取到的是事务 A 修改后**已提交**的数据，即 `stock = 0`。
5.  事务 B 判断库存不足（0 < 1），抛出异常，执行回滚。
6.  **最终结果**：只有事务 A 成功购买，库存正确地减少为 0。更新丢失问题被成功解决。

## 死锁 (Deadlock)

使用锁机制时，需要注意一种特殊情况：**死锁**。

-   **定义**：指两个或多个事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。
-   **简单例子**：
    1.  事务 A 锁定了**行 1**，然后试图去锁定**行 2**。
    2.  与此同时，事务 B 锁定了**行 2**，然后试图去锁定**行 1**。
    3.  此时，A 在等 B 释放行 2 的锁，而 B 在等 A 释放行 1 的锁，两个事务都无法继续进行，形成死锁。

InnoDB 有一个内置的**死锁检测机制**。当它检测到死锁时，会选择一个“成本”最小的事务作为“牺牲品”，将其**强制回滚**，从而让另一个事务可以继续执行。

**对开发者的启示**：
-   由于死锁的发生和自动回滚，你的应用程序代码**必须**准备好处理因此而抛出的异常。
-   一个常见的策略是，在 `catch` 块中捕获到死锁特有的异常码后，可以等待一小段时间，然后**重新尝试执行整个事务**。

--- 

## 总结

-   悲观锁假设冲突会发生，因此在操作前先加锁。
-   它适用于高竞争的写密集型场景。
-   InnoDB 主要通过行级共享锁 (`FOR SHARE`) 和排他锁 (`FOR UPDATE`) 来实现。
-   `SELECT ... FOR UPDATE` 是解决“更新丢失”问题的经典方案。
-   使用悲观锁时，需要注意处理可能发生的死锁情况。

悲观锁是一种强大但成本较高的并发控制手段。在下一节，我们将学习另一种更轻量级的策略——乐观锁。

--- 

## 练习任务

1.  **共享锁的应用**：
    假设在一个财务系统中，当一个复杂的报表正在生成时（需要读取多个账户的余额），你不希望在报表生成期间有任何账户的余额发生变动。你应该如何使用共享锁来实现这个需求？请写出核心的 `SELECT` 语句。

2.  **死锁模拟**：
    尝试设计一个场景，使用两张表（例如 `table_a` 和 `table_b`），并编写两个并发执行的 PHP 脚本（可以手动快速地先后执行它们），来稳定地触发一次死锁。观察并记录 MySQL 返回的错误信息。

3.  **悲观锁 vs MVCC**：
    思考并回答：既然有了 MVCC，为什么还需要悲观锁？在 `REPEATABLE READ` 隔离级别下，一个普通的 `SELECT` (快照读) 和 `SELECT ... FOR UPDATE` (当前读) 在读取数据时，最本质的区别是什么？
