# 6.3.1 并发问题与隔离级别 (Concurrency Issues & Isolation Levels)

## 概述

现代数据库系统几乎无时无刻不在处理来自多个客户端（用户、应用程序进程）的**并发请求**。**并发控制 (Concurrency Control)** 的目标就是在保证数据一致性的前提下，尽可能地提升多用户同时访问数据库时的性能。

如果没有任何并发控制，系统可能会因为多个事务的交叉执行而导致各种意想不到的数据异常。为了理解并发控制的重要性，我们首先需要了解在并发环境下可能出现的三大典型问题：**脏读、不可重复读和幻读**。

## 并发访问的三大问题

为了清晰地解释这些问题，我们假设有两个并发执行的事务：事务 A 和事务 B。

### 1. 脏读 (Dirty Read)

-   **定义**：事务 A 读取到了事务 B **已经修改但尚未提交**的数据。如果事务 B 随后进行了回滚 (Rollback)，那么事务 A 读取到的数据就是“脏”的，因为它在数据库中从未正式存在过。
-   **危害**：这是最严重的数据一致性问题，因为它会导致应用程序基于一个从未真实存在过的值做出决策。
-   **示例时间线**:
    1.  事务 A 开始。
    2.  事务 B 开始。
    3.  事务 B 执行 `UPDATE` 操作，将某商品的库存从 10 修改为 5。
    4.  事务 A 执行 `SELECT` 操作，读取到该商品的库存为 5。
    5.  事务 B 因为某种原因执行了 `ROLLBACK`，商品的库存恢复为 10。
    6.  此时，事务 A 持有的数据“库存为 5”就是一个无效的脏数据。

### 2. 不可重复读 (Non-Repeatable Read)

-   **定义**：在一个事务（事务 A）内部，两次执行**相同的查询**，但返回了不同的结果。这是因为在这两次查询之间，有另一个事务（事务 B）**修改或删除**了这些数据并提交了。
-   **侧重点**：问题的关键在于**修改 (UPDATE)** 或 **删除 (DELETE)** 了**同一条**数据。
-   **危害**：破坏了事务内部的一致性。事务在执行过程中，它所依赖的数据发生了意想不到的变化。
-   **示例时间线**:
    1.  事务 A 开始，执行 `SELECT * FROM products WHERE id = 1`，读取到商品价格为 100 元。
    2.  事务 B 开始。
    3.  事务 B 执行 `UPDATE products SET price = 120 WHERE id = 1`，并**提交** (`COMMIT`)。
    4.  事务 A 再次执行 `SELECT * FROM products WHERE id = 1`，读取到的商品价格变成了 120 元。
    5.  对于事务 A 来说，它在同一个事务中两次读取同一行数据，得到了不同的结果，即“不可重复读”。

### 3. 幻读 (Phantom Read)

-   **定义**：在一个事务（事务 A）内部，执行一个范围查询（例如，`WHERE age > 25`）。之后，另一个事务（事务 B）在该范围内**插入 (INSERT)** 了一条新数据并提交。当事务 A 再次执行相同的范围查询时，会发现结果集中多出了一条之前不存在的“幻影”记录。
-   **与不可重复读的区别**：不可重复读侧重于单行数据的**修改/删除**，而幻读侧重于多行数据集的**增加**。
-   **危害**：同样破坏了事务的一致性，尤其是在需要对一个数据集进行统计或批量处理的场景中。
-   **示例时间线**:
    1.  事务 A 开始，执行 `SELECT COUNT(*) FROM employees WHERE department_id = 10`，得到结果为 5。
    2.  事务 B 开始。
    3.  事务 B 执行 `INSERT INTO employees (name, department_id) VALUES ('New Employee', 10)`，并**提交** (`COMMIT`)。
    4.  事务 A 为了后续操作，再次执行 `SELECT COUNT(*) FROM employees WHERE department_id = 10`，得到的结果变成了 6。
    5.  对于事务 A 来说，第二次查询多出了一条“幻影”记录。

## 事务隔离级别 (Transaction Isolation Levels)

为了解决上述问题，SQL 标准定义了四种事务隔离级别。隔离级别越高，数据一致性越好，但并发性能可能会越低。

| 隔离级别                  | 脏读 (Dirty Read) | 不可重复读 (Non-Repeatable Read) | 幻读 (Phantom Read) |
|:--------------------------|:------------------|:---------------------------------|:--------------------|
| **读未提交 (Read Uncommitted)** | 允许              | 允许                             | 允许                |
| **读已提交 (Read Committed)**   | 不允许            | 允许                             | 允许                |
| **可重复读 (Repeatable Read)**  | 不允许            | 不允许                           | 允许 (理论上)¹     |
| **可串行化 (Serializable)**     | 不允许            | 不允许                           | 不允许              |

> ¹ **注意**：在 MySQL 的 InnoDB 存储引擎中，其默认的**可重复读**隔离级别，通过 MVCC 机制，在很大程度上已经解决了幻读问题（针对快照读），使其行为比标准定义的“可重复读”更强大。

### 1. 读未提交 (Read Uncommitted)

-   **描述**：最低的隔离级别。一个事务可以看到其他事务未提交的修改。
-   **后果**：连脏读都无法避免，现实中几乎从不使用。

### 2. 读已提交 (Read Committed)

-   **描述**：一个事务只能读取到其他事务**已经提交**的数据。
-   **解决了**：脏读问题。
-   **如何实现**：通常通过在读取数据时加锁，或者通过 MVCC 实现（每次 `SELECT` 都创建一个新的快照）。
-   **这是 Oracle、PostgreSQL 等数据库的默认隔离级别**。

### 3. 可重复读 (Repeatable Read)

-   **描述**：确保在一个事务内部，对同一行数据的多次读取结果都是一致的，除非数据是被这个事务自己修改的。
-   **解决了**：脏读和不可重复读问题。
-   **如何实现**：通过 MVCC 实现（在事务开始时创建一个快照，后续所有 `SELECT` 都基于此快照），或者通过更强的锁机制。
-   **这是 MySQL InnoDB 存储引擎的默认隔离级别**。

### 4. 可串行化 (Serializable)

-   **描述**：最高的隔离级别。它强制事务串行执行，即一个接一个地执行，完全避免了并发问题。
-   **解决了**：脏读、不可重复读和幻读问题。
-   **如何实现**：通常通过对事务涉及的所有数据范围进行加锁（范围锁）来实现。
-   **后果**：并发性能最差，只在对数据一致性有极高要求的场景下使用（例如，银行的某些核心交易系统）。

## 设置隔离级别

你可以为当前会话或全局设置事务隔离级别。

**查看当前隔离级别**:
```sql
-- MySQL 8+
SELECT @@transaction_isolation;

-- 老版本
SELECT @@tx_isolation;
```

**设置当前会话的隔离级别**:
```sql
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

---

## 总结

理解并发问题和隔离级别是深入学习数据库锁机制和 MVCC 的前提。在日常开发中，我们通常使用数据库的默认隔离级别（对于 MySQL InnoDB 来说是**可重复读**），这个级别在一致性和性能之间取得了很好的平衡。当遇到需要更强一致性保证的特殊业务场景时，我们才会考虑提升隔离级别或手动使用锁。

在下一节中，我们将探讨 InnoDB 是如何通过 MVCC 这一强大机制，在“可重复读”级别下高效地解决并发读取问题的。

---

## 练习任务

1.  **情景分析**：
    一个在线票务系统，在多个窗口同时售卖某场演出的门票。当一个窗口查询余票数量时，另一个窗口正在处理一个购票请求（该请求会减少余票，但尚未完成支付确认，即事务未提交）。请问，如果数据库隔离级别是“读未提交”，查询余票的窗口可能会遇到什么问题？如果隔离级别是“读已提交”呢？

2.  **隔离级别与性能**：
    查阅资料并思考：为什么说隔离级别越高，并发性能就越差？请以“可重复读”和“可串行化”为例，简要说明“可串行化”可能在哪些方面牺牲了性能。

3.  **MySQL 默认级别**：
    连接到你的本地 MySQL 数据库，执行 `SELECT @@transaction_isolation;` 命令，确认你的 InnoDB 存储引擎默认的事务隔离级别是什么，并解释为什么 MySQL 选择这个级别作为默认值（提示：考虑历史原因和与二进制日志复制的兼容性）。
