# 6.3.2 MVCC 核心原理 (Core Principles of MVCC)

## 概述

**MVCC (Multi-Version Concurrency Control)**，即**多版本并发控制**，是现代数据库（尤其是读操作非常频繁的系统）中用于提升并发性能的一项核心技术。与传统的、完全依赖于锁的机制不同，MVCC 的核心思想是**“读写不阻塞”**：读取数据时不需要获取锁，写入数据时也只锁定必要的行。

简单来说，MVCC 通过为每一行数据保存多个历史版本，使得不同的事务可以根据其启动时间，查看到数据库在特定时间点的“快照”，从而避免了因写操作而阻塞读操作，反之亦然。MySQL 的 InnoDB 存储引擎正是利用 MVCC 来实现了 `REPEATABLE READ`（可重复读）和 `READ COMMITTED`（读已提交）这两种隔离级别。

## MVCC 的三大核心组件

InnoDB 实现 MVCC 主要依赖于三个底层组件：**隐藏列**、**Undo Log** 和 **Read View**。

### 1. 隐藏列 (Hidden Columns)

在 InnoDB 中，除了我们自己定义的列外，每一行记录还会额外包含几个隐藏的列，其中与 MVCC 最相关的有两个：
-   `DB_TRX_ID` (6字节): 记录了**最近一次**修改（插入或更新）该行记录的**事务ID**。
-   `DB_ROLL_PTR` (7字节): **回滚指针**。它指向该行记录的上一个版本，这些历史版本被存储在 **Undo Log** 中。

### 2. Undo Log (回滚日志)

当事务执行 `UPDATE` 或 `DELETE` 操作时，InnoDB 不会直接覆盖或物理删除旧数据。相反，它会执行以下操作：
1.  将原始的行数据（旧版本）复制一份，存入 **Undo Log** 中。
2.  修改当前行的数据，并将该行的 `DB_TRX_ID` 更新为当前事务的 ID。
3.  通过 `DB_ROLL_PTR` 回滚指针，将当前行指向刚刚存入 Undo Log 的旧版本。

这样，一行数据的多个历史版本就通过 `DB_ROLL_PTR` 形成了一个**版本链 (Version Chain)**。链首是当前最新的数据，链尾是最原始的数据。

![Version Chain Diagram](https://i.imgur.com/8Q6wX2z.png)
*图：一行数据被多个事务修改后形成的版本链*

### 3. Read View (一致性读视图)

Read View 是 MVCC 的“大脑”，它决定了一个事务在启动时能“看到”哪些数据版本。当一个事务需要读取数据时（执行 `SELECT`），它会根据当前的数据库状态创建一个 Read View。这个 Read View 本质上是一个数据结构，记录并定义了当前事务可见的数据范围。

一个 Read View 主要包含以下四个重要属性：
-   `m_ids`: 一个列表，包含在**创建此 Read View 时**，数据库中所有**活跃且未提交**的事务 ID。
-   `min_trx_id`: `m_ids` 列表中的最小事务 ID。
-   `max_trx_id`: 数据库系统准备分配给下一个新事务的 ID（即当前最大事务ID + 1）。
-   `creator_trx_id`: 创建此 Read View 的事务自身的 ID。

#### 可见性判断算法

当事务要去读取某一行数据时，它会拿出自己的 Read View，并对该行记录的 `DB_TRX_ID` 执行以下一套**可见性判断算法**：

1.  如果 `DB_TRX_ID` **等于** `creator_trx_id`？
    -   是：说明这一行是当前事务自己修改的，**可见**。

2.  如果 `DB_TRX_ID` **小于** `min_trx_id`？
    -   是：说明修改这一行的事务在当前事务**启动前就已提交**，**可见**。

3.  如果 `DB_TRX_ID` **大于或等于** `max_trx_id`？
    -   是：说明修改这一行的事务是在当前事务**启动后才开启**的，**不可见**。

4.  如果 `DB_TRX_ID` 在 `min_trx_id` 和 `max_trx_id` 之间？
    -   此时，需要检查 `DB_TRX_ID` 是否存在于 `m_ids` 列表中。
    -   **存在**：说明修改这一行的事务在当前事务启动时**仍然活跃（未提交）**，**不可见**。
    -   **不存在**：说明修改这一行的事务在当前事务启动时**已经提交**，**可见**。

如果根据以上算法判断当前版本**不可见**，InnoDB 就会顺着 `DB_ROLL_PTR` 指针去 Undo Log 中查找**上一个版本**，然后对上一个版本的数据**再次应用**这套可见性算法，直到找到一个可见的版本为止。

## MVCC 在不同隔离级别下的工作方式

Read View 的**创建时机**，决定了不同隔离级别的行为。

-   **`REPEATABLE READ` (可重复读 - InnoDB 默认)**
    -   **Read View 创建时机**：在事务中的**第一个 `SELECT` 语句执行时**创建。
    -   **行为**：一旦创建，该 Read View 会被**复用**于该事务内的所有后续 `SELECT` 查询。因为 Read View 是固定的，所以无论其他事务如何修改并提交数据，当前事务看到的总是在它启动那一刻的数据库“快照”，从而实现了“可重复读”。

-   **`READ COMMITTED` (读已提交)**
    -   **Read View 创建时机**：在事务中的**每一个 `SELECT` 语句执行时**都会创建一个**新的** Read View。
    -   **行为**：因为每次查询都会生成新的 Read View，所以当前事务能够读取到其他已经提交的事务所做的最新修改。这就导致了“不可重复读”现象的发生，但避免了“脏读”。

## 快照读 (Snapshot Read) vs 当前读 (Current Read)

理解 MVCC 时，必须区分 InnoDB 中的两种读取方式：

-   **快照读 (Snapshot Read)**
    -   **定义**：指使用 MVCC 机制来读取数据的方式，它读取的是行数据的某个历史版本快照，是一种**非锁定**的读操作。
    -   **触发场景**：普通的 `SELECT` 语句，只要不带 `FOR UPDATE` 或 `LOCK IN SHARE MODE`。
    -   **特点**：性能高，因为不需要加锁，读写不冲突。

-   **当前读 (Current Read)**
    -   **定义**：指读取数据库中**最新提交的版本**，并对读取的记录进行**加锁**，以保证其他并发事务不能修改这些记录。
    -   **触发场景**：
        -   `SELECT ... LOCK IN SHARE MODE` (加共享锁)
        -   `SELECT ... FOR UPDATE` (加排他锁)
        -   `INSERT`, `UPDATE`, `DELETE` (这些写操作在执行前，都需要先“当前读”到最新的数据，然后在其上进行修改并加锁)
    -   **特点**：保证了数据的一致性，但会牺牲一定的并发性能。

**重要**：MVCC 主要服务于“快照读”。“当前读”则依赖于下一节将要介绍的**锁机制**。

---

## 总结

MVCC 是一个优雅的设计，它通过“空间换时间”的思路（存储多个版本），极大地提升了数据库的并发读性能。
-   它依赖**版本链**和 **Read View** 来实现。
-   Read View 的创建时机决定了**隔离级别**。
-   它主要用于实现**快照读**，与需要加锁的**当前读**相对应。

理解了 MVCC，你就理解了为什么在 MySQL 中，普通的 `SELECT` 查询如此之快，以及为什么在默认的“可重复读”级别下，我们通常不会遇到“不可重复读”和“幻读”的问题。

---

## 练习任务

1.  **解释 Repeatable Read**：
    用你自己的话，结合版本链和 Read View 的概念，向一个初学者解释为什么在 InnoDB 的默认隔离级别下，一个事务内部多次执行相同的 `SELECT` 查询总能得到相同的结果。

2.  **Read Committed vs Repeatable Read**：
    假设一个事务 A 开启了，但还未执行任何查询。此时，事务 B 更新了一行数据并提交。然后，事务 A 执行了它的第一个 `SELECT`。请问，在 `READ COMMITTED` 和 `REPEATABLE READ` 两种隔离级别下，事务 A 分别能看到什么数据？为什么？

3.  **识别读类型**：
    在不考虑事务隔离级别的情况下，判断以下操作属于“快照读”还是“当前读”：
    -   `SELECT * FROM users WHERE id = 1;`
    -   `UPDATE users SET name = 'new_name' WHERE id = 1;`
    -   在一个事务中，先 `SELECT` 了一个商品的库存，然后根据库存判断是否执行 `UPDATE`。
    -   `SELECT * FROM products WHERE category = 'books' FOR UPDATE;`
