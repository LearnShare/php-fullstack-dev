# 6.1.4 数据类型选择 (Data Type Selection)

## 概述

在数据库设计中，为表中的每个字段选择正确的数据类型是一项至关重要的任务。这不仅直接影响数据的存储效率和准确性，还对查询性能、数据完整性和应用逻辑产生深远的影响。错误的数据类型选择可能导致存储空间浪费、性能下降，甚至引发难以排查的数据错误。

选择数据类型的核心原则是：**在满足业务需求的前提下，选择最小、最合适的数据类型。**

-   **最小 (Smallest)**：更小的数据类型意味着占用更少的磁盘空间、内存和 CPU 缓存，从而加快数据传输和处理速度。
-   **最合适 (Most Appropriate)**：数据类型应与数据的内在属性相匹配。例如，用数值类型存储年龄，用日期类型存储生日，这可以利用数据库内置的验证和函数功能。

本节将详细介绍 MySQL 中常用的数据类型，并提供选择它们的最佳实践。

---

## 数值类型 (Numeric Types)

数值类型用于存储各种数字，如年龄、价格、数量等。

### 1. 整数类型 (Integer Types)

整数类型用于存储没有小数部分的数字。选择哪种整数类型取决于你的数据可能达到的最大值。始终优先选择能容纳你的数据范围的最小类型。

| 类型        | 存储空间 (字节) | 范围 (有符号, Signed)                           | 范围 (无符号, Unsigned)                     | 常见用途             |
|:------------|:----------------|:------------------------------------------------|:--------------------------------------------|:---------------------|
| `TINYINT`   | 1               | -128 到 127                                     | 0 到 255                                    | 状态、标志位、年龄   |
| `SMALLINT`  | 2               | -32,768 到 32,767                               | 0 到 65,535                                 | 文章分类数、小范围ID |
| `MEDIUMINT` | 3               | -8,388,608 到 8,388,607                         | 0 到 16,777,215                             | 中等范围ID         |
| `INT`       | 4               | -2,147,483,648 到 2,147,483,647                 | 0 到 4,294,967,295                          | 大多数表的主键ID     |
| `BIGINT`    | 8               | -9,223,372,036,854,775,808 到 ... (极大)        | 0 到 18,446,744,073,709,551,615 (极大)      | 分布式系统ID、海量数据ID |

**最佳实践**：
-   如果一个字段（如自增ID）永远不会是负数，务必使用 `UNSIGNED` 关键字。这能使存储范围扩大一倍。
-   对于存储状态（如 `0:未支付, 1:已支付, 2:已发货`）的字段，`TINYINT UNSIGNED` 是最佳选择。
-   `INT UNSIGNED` 是绝大多数表主键 `id` 的首选。只有在确定数据量会超过 42 亿时，才需要考虑 `BIGINT`。

### 2. 定点数类型 (Fixed-Point Type)

-   `DECIMAL(M, D)`
    -   **定义**：用于存储需要精确计算的十进制数，特别是**货币**。`M` 是总位数，`D` 是小数位数。
    -   **特点**：`DECIMAL` 以字符串形式存储，避免了浮点数带来的精度损失问题。计算开销比浮点数大，但能保证绝对精确。
    -   **示例**：`price DECIMAL(10, 2)` 表示 `price` 字段最多有 10 位数字，其中 2 位是小数，取值范围从 -99,999,999.99 到 99,999,999.99。

### 3. 浮点数类型 (Floating-Point Types)

-   `FLOAT(M, D)` 和 `DOUBLE(M, D)`
    -   **定义**：用于存储近似值的数值，`FLOAT` 是单精度，`DOUBLE` 是双精度。
    -   **特点**：存在精度损失风险。例如，存储 0.1，内部可能表示为 0.10000000149011612。因此，**绝对不能用于存储货币等需要精确计算的数值**。
    -   **应用场景**：科学计算、存储经纬度等对精度要求不那么严格的场景。

---

## 字符串类型 (String Types)

### 1. `CHAR` vs. `VARCHAR`

这是最常被问及的一对类型，它们的选择对性能有直接影响。

-   `CHAR(N)`
    -   **定义**：**定长**字符串。`N` 的范围是 0-255。无论实际存储的字符串有多长，它都会占用 `N` 个字符的存储空间。如果存入的字符串长度小于 `N`，数据库会自动在末尾填充空格。
    -   **优点**：处理速度快，因为长度固定，无需计算长度。
    -   **适用场景**：长度非常固定且基本不变的字段，如 MD5 哈希值 (`CHAR(32)`), UUID (`CHAR(36)`), 性别 (`CHAR(1)`), 国家代码 (`CHAR(2)`)。

-   `VARCHAR(N)`
    -   **定义**：**变长**字符串。`N` 的范围是 0-65,535 (实际受行大小限制)。它只占用实际字符串长度加上 1-2 个字节（用于记录长度）的空间。
    -   **优点**：节省存储空间。
    -   **适用场景**：绝大多数的字符串存储需求，如用户名、邮箱、标题、地址等长度不固定的字段。

**最佳实践**：
-   除非你明确知道一个字段的长度是固定的，否则**总是优先使用 `VARCHAR`**。
-   `VARCHAR(N)` 中的 `N` 并非越大越好。应根据业务预估的最大长度来设定一个合理的 `N` 值。虽然它不直接影响磁盘占用，但会影响内存中为该行分配的缓冲区大小。

### 2. 文本类型 (Text Types)

当 `VARCHAR` 的长度不足以满足需求时，就需要使用文本类型。

| 类型          | 最大存储长度 (字符) |
|:--------------|:--------------------|
| `TINYTEXT`    | 255                 |
| `TEXT`        | 65,535 (64KB)       |
| `MEDIUMTEXT`  | 16,777,215 (16MB)   |
| `LONGTEXT`    | 4,294,967,295 (4GB) |

**最佳实践**：
-   `TEXT` 类型通常存储在表外的一个特殊区域，查询时需要额外的 I/O 开销。因此，应避免在 `TEXT` 字段上建立索引（若要索引，应使用前缀索引或全文索引），也尽量避免在查询中频繁 `SELECT` 这些大字段，除非确实需要。
-   能用 `VARCHAR` 解决的，就不要用 `TEXT`。

---

## 日期和时间类型 (Date and Time Types)

使用数据库原生的日期时间类型，而不是用字符串或整数来存储时间，可以利用数据库丰富的日期计算函数。

| 类型        | 格式                      | 范围                                      | 存储空间 (字节) | 特点                                           |
|:------------|:--------------------------|:------------------------------------------|:----------------|:-----------------------------------------------|
| `DATE`      | 'YYYY-MM-DD'              | '1000-01-01' 到 '9999-12-31'              | 3               | 只存储日期                                     |
| `TIME`      | 'HH:MM:SS'                | '-838:59:59' 到 '838:59:59'               | 3               | 只存储时间或时间间隔                           |
| `DATETIME`  | 'YYYY-MM-DD HH:MM:SS'     | '1000-01-01 00:00:00' 到 '9999-12-31...' | 8               | 与时区无关，存储的是字面上的日期时间         |
| `TIMESTAMP` | 'YYYY-MM-DD HH:MM:SS'     | '1970-01-01 00:00:01' UTC 到 '2038-01-19...' | 4               | **与时区相关**，存储时转为 UTC，读取时转回当前时区 |
| `YEAR`      | YYYY                      | 1901 到 2155                              | 1               | 存储年份                                       |

### `DATETIME` vs. `TIMESTAMP`

-   **`TIMESTAMP`**：
    -   **优点**：占用空间小 (4字节)，自动处理时区转换，非常适合需要国际化的应用。它还有一个特殊属性，在插入或更新行时可以自动更新为当前时间（`ON UPDATE CURRENT_TIMESTAMP`）。
    -   **缺点**：范围较小，会受到著名的“2038年问题”的影响。
    -   **适用场景**：记录创建时间 (`created_at`)、更新时间 (`updated_at`)。

-   **`DATETIME`**：
    -   **优点**：范围大，不受时区影响，存储的是所见即所得的时间。
    -   **缺点**：占用空间大 (8字节)，不自动处理时区。
    -   **适用场景**：存储一个固定的、与时区无关的日期时间，如用户的生日、活动开始时间。

---

## 其他类型

### `ENUM` 和 `SET`

-   **`ENUM('value1', 'value2', ...)`**: 枚举类型。字段的值只能是预定义列表中的**一个**。内部以整数形式存储（1, 2, 3...），非常高效。
    -   **示例**：`status ENUM('active', 'inactive', 'pending')`
-   **`SET('value1', 'value2', ...)`**: 集合类型。字段的值可以是预定义列表中的**零个或多个**。内部以位图形式存储。

**争议与建议**：虽然 `ENUM` 和 `SET` 在存储上很高效，但它们也存在争议。主要问题在于修改预定义列表（如增加一个新状态）需要执行 `ALTER TABLE`，这是一个高成本操作，可能导致锁表。在许多现代应用中，开发者更倾向于使用 `TINYINT` 配合应用层的常量/枚举来管理状态，或者建立一个单独的状态映射表，这样更具灵活性。

### `JSON` 类型

自 MySQL 5.7 起，引入了原生的 `JSON` 数据类型。

-   **优点**：
    -   **自动验证**：存入时会自动校验是否为合法的 JSON 格式。
    -   **优化的存储格式**：内部以二进制格式存储，查询 JSON 内部的元素比在 `TEXT` 中存储 JSON 字符串再由应用解析要快得多。
    -   **强大的函数支持**：提供了丰富的函数（如 `JSON_EXTRACT`, `JSON_OBJECT`, `JSON_ARRAY`）来操作和查询 JSON 数据。
-   **适用场景**：存储不固定结构的配置信息、日志、用户标签等。

---

## 练习任务

1.  **用户注册表设计**：
    设计一个用户表 `users`，包含以下字段：自增ID、用户名（最长50个字符）、密码哈希（60个字符定长，由 `password_hash()` 生成）、邮箱（最长100个字符）、账户余额、用户状态（未激活、已激活、已封禁）、注册IP、最后登录时间。请为每个字段选择最合适的数据类型，并写出 `CREATE TABLE` 语句。

2.  **`CHAR` vs. `VARCHAR` 场景分析**：
    请至少举出两个适合使用 `CHAR` 而不是 `VARCHAR` 的具体业务场景，并说明理由。

3.  **时间存储方案**：
    一个国际化的电商应用需要记录订单的创建时间。这个时间需要被全球各地的运营人员查看，每个人都希望看到自己所在时区的时间。请问你应该选择 `DATETIME` 还是 `TIMESTAMP` 来存储订单创建时间？为什么？
