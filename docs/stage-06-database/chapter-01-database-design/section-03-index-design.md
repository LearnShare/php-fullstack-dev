# 6.1.3 索引设计与优化 (Index Design and Optimization)

## 概述

如果说规范化是为了保证数据的质量，那么**索引 (Index)** 就是为了提升数据的访问**速度**。索引是数据库中一种特殊的数据结构，它允许数据库引擎在不扫描整个表的情况下，快速定位到符合条件的记录。这极大地提升了数据检索（`SELECT` 查询）的性能。

可以将数据库索引类比为一本书的目录。如果没有目录，要找到某个特定的主题，你需要从头到尾翻阅整本书。而有了目录，你可以直接根据主题查到对应的页码，然后快速翻到那一页。在数据库中，这个“页码”就相当于指向数据行物理位置的指针。

本节将深入探讨索引的工作原理、不同类型的索引、设计索引的最佳实践，以及如何避免常见的索引失效场景。掌握索引是数据库性能优化的核心技能。

---

## 索引的工作原理

### 核心数据结构：B-Tree

大多数关系型数据库（如 MySQL 的 InnoDB 存储引擎）主要使用 **B-Tree** (或其变体 B+Tree) 作为索引的数据结构。B-Tree 是一种自平衡的树，它能够保持数据有序，并允许在对数时间内进行查找、顺序访问、插入和删除操作。

**B-Tree 的特点**：
-   **节点存储数据**：每个节点不仅包含键（如 `id` 的值），还包含指向数据行物理地址的指针。
-   **平衡性**：树的所有叶子节点都处于同一层级，这保证了从根节点到任何一个叶子节点的路径长度都大致相同，从而确保了查询性能的稳定性。
-   **多路查找**：每个节点可以有多个子节点，这减少了树的高度，从而减少了磁盘 I/O 的次数。

**查询过程**：
当你在一个建立了 B-Tree 索引的列上执行查询时（例如 `SELECT * FROM users WHERE id = 100;`），数据库引擎会：
1.  从 B-Tree 的根节点开始。
2.  通过比较 `100` 和节点中存储的键值，决定下一步要去哪个子节点。
3.  重复此过程，直到找到包含 `100` 这个键的叶子节点。
4.  从该叶子节点中获取到对应数据行的物理地址。
5.  根据物理地址，直接从磁盘中读取数据行。

这个过程非常快，因为它避免了逐行扫描整张表的“全表扫描 (Full Table Scan)”。

---

## 索引的类型

根据不同的应用场景和约束，索引可以分为多种类型：

1.  **主键索引 (Primary Key Index)**
    -   **定义**：一种特殊的唯一索引，它不允许有空值。每个表只能有一个主键索引。在创建主键时，数据库会自动创建对应的主键索引。
    -   **特点**：在 MySQL InnoDB 中，主键索引是**聚簇索引 (Clustered Index)**，这意味着数据表的物理存储顺序与主键的顺序是一致的。因此，基于主键的查询速度最快。

2.  **唯一索引 (Unique Index)**
    -   **定义**：确保索引列的所有值都是唯一的，但允许有空值（`NULL`）。一个表可以有多个唯一索引。
    -   **应用场景**：当业务上要求某个字段（如用户邮箱、身份证号）不能重复时使用。

3.  **普通索引 (Normal Index / Non-unique Index)**
    -   **定义**：最基本的索引类型，它不要求索引列的值具有唯一性。
    -   **应用场景**：用于加速任何非唯一字段的查询，例如用户姓名、城市等。

4.  **复合索引 (Composite Index / Multi-column Index)**
    -   **定义**：在一个索引中包含多个列。
    -   **应用场景**：当查询条件（`WHERE` 子句）经常涉及到多个列时，复合索引非常有效。
    -   **重要原则**：**最左前缀原则 (Leftmost Prefix Principle)**。一个复合索引 `(col1, col2, col3)`，相当于创建了 `(col1)`、`(col1, col2)` 和 `(col1, col2, col3)` 三个索引。查询条件必须从索引的最左边的列开始，才能有效利用索引。例如，`WHERE col1 = ?` 或 `WHERE col1 = ? AND col2 = ?` 可以使用该索引，但 `WHERE col2 = ?` 则无法使用。

5.  **全文索引 (Full-text Index)**
    -   **定义**：专门用于在大量文本数据中进行关键词搜索的索引。它不像 `LIKE '%keyword%'` 那样进行全表扫描，而是通过分词和倒排索引等技术实现快速搜索。
    -   **应用场景**：文章内容、商品描述等文本字段的搜索。

---

## 索引设计原则与最佳实践

创建索引并非没有成本。索引会占用额外的磁盘空间，并且在进行插入、更新、删除操作时，数据库引擎也需要花费额外的时间来维护索引结构。因此，创建“好”的索引至关重要。

1.  **为频繁作为查询条件的列创建索引**
    -   **规则**：经常出现在 `WHERE` 子句、`JOIN` 的连接条件 (`ON` 子句) 和 `ORDER BY` 子句中的列，是索引的首选。
    -   **示例**：`SELECT * FROM orders WHERE customer_id = ? ORDER BY order_date DESC;`，应该为 `customer_id` 和 `order_date` 创建索引。一个 `(customer_id, order_date)` 的复合索引会是最佳选择。

2.  **选择高区分度的列 (High Selectivity)**
    -   **规则**：列中不同值的数量（基数, Cardinality）越多，区分度就越高，索引的效果就越好。
    -   **示例**：`身份证号` 几乎是全唯一的，区分度极高，非常适合做索引。而 `性别` 字段只有“男”、“女”等几个值，区分度很低，为其创建索引几乎没有性能提升，因为每次查询可能会返回表中近一半的数据，数据库引擎可能宁愿选择全表扫描。

3.  **利用最左前缀原则设计复合索引**
    -   **规则**：在创建复合索引时，应将最常用、区分度最高的列放在最左边。
    -   **示例**：如果查询经常是 `WHERE name = ? AND age = ?`，并且 `name` 的区分度高于 `age`，那么 `(name, age)` 是一个比 `(age, name)` 更好的复合索引。

4.  **避免创建过多索引**
    -   **规则**：索引会增加写操作（`INSERT`, `UPDATE`, `DELETE`）的成本。每个额外的索引都会拖慢写操作的速度。因此，只保留那些真正被频繁使用的、能带来显著性能提升的索引。定期审查并删除无用的索引。

5.  **索引列不应过长**
    -   **规则**：索引键越长，B-Tree 的节点占用的空间就越大，导致树的高度增加，磁盘 I/O 次数增多。
    -   **实践**：对于 `VARCHAR` 类型的长字段，可以考虑使用**前缀索引**，只索引字段的前 N 个字符。例如 `CREATE INDEX idx_title ON posts (title(20));`。但这会降低索引的区分度，需要权衡。

---

## 索引失效的常见场景

即使创建了索引，某些查询的写法也可能导致数据库引擎放弃使用索引，转而进行全表扫描。

1.  **在索引列上使用函数或表达式**
    -   **反例**: `SELECT * FROM users WHERE YEAR(created_at) = 2026;`
    -   **原因**: `YEAR()` 函数作用于 `created_at` 列上，数据库无法直接使用 `created_at` 的索引。
    -   **优化**: 将查询改写为范围查询。`SELECT * FROM users WHERE created_at >= '2026-01-01' AND created_at < '2027-01-01';`

2.  **使用 `LIKE` 并且以通配符 `%` 开头**
    -   **反例**: `SELECT * FROM articles WHERE content LIKE '%database%';`
    -   **原因**: 查询以通配符开头，索引无法确定起始点，只能进行全表扫描。
    -   **优化**: 如果业务允许，尽量使用后缀匹配 `content LIKE 'database%';`，这样索引仍然有效。对于全文搜索需求，应使用全文索引。

3.  **使用 `OR` 连接非索引列**
    -   **反例**: `SELECT * FROM orders WHERE customer_id = 100 OR amount > 5000;` (假设 `amount` 列没有索引)
    -   **原因**: 优化器可能会认为，扫描 `customer_id` 的索引结果集，再扫描全表找出 `amount > 5000` 的记录，最后合并结果，这个过程比直接全表扫描一次更复杂。
    -   **优化**: 确保 `OR` 两边的条件列都有索引。

4.  **数据类型不匹配**
    -   **反例**: 假设 `phone` 字段是 `VARCHAR` 类型并有索引。`SELECT * FROM users WHERE phone = 13800138000;`
    -   **原因**: 查询中的 `13800138000` 是一个数字，而索引列是字符串。数据库会进行隐式类型转换，这可能导致索引失效。
    -   **优化**: 确保查询值的数据类型与列定义一致。`SELECT * FROM users WHERE phone = '13800138000';`

### 分析索引使用情况：EXPLAIN 命令

在 MySQL 中，`EXPLAIN` 命令是性能优化的利器。将它放在 `SELECT` 语句前，可以分析查询的执行计划，告诉你数据库将如何执行这个查询。

`EXPLAIN SELECT * FROM users WHERE id = 10;`

输出结果中的 `type` 和 `key` 字段非常关键：
-   `type`: 显示连接类型。常见的值从好到坏依次是 `system` > `const` > `eq_ref` > `ref` > `range` > `index` > `ALL`。`ALL` 表示全表扫描，是需要重点优化的对象。
-   `key`: 显示实际使用的索引。如果为 `NULL`，则表示没有使用索引。

---

## 练习任务

1.  **为用户表设计索引**：
    假设你有一个 `users` 表，包含 `id` (主键), `username` (唯一), `email` (唯一), `city`, `age`, `created_at` 字段。常见的查询有：
    -   通过 `username` 登录。
    -   按 `city` 和 `age` 筛选用户。
    -   查找某一天 (`created_at`) 注册的所有用户。
    请为这个表设计一套合理的索引方案，并写出 `CREATE INDEX` 语句。

2.  **复合索引优化**：
    一个 `products` 表有 `category_id` 和 `brand_id` 两个字段。现在需要支持两个查询场景，一个是通过 `category_id` 查找商品，另一个是同时通过 `category_id` 和 `brand_id` 查找。请问以下哪个索引方案更好，并说明为什么？
    -   方案A：创建两个单列索引 `idx_cat(category_id)` 和 `idx_brand(brand_id)`。
    -   方案B：创建一个复合索引 `idx_cat_brand(category_id, brand_id)`。

3.  **分析索引失效**：
    分析以下查询，并解释为什么它可能无法有效利用 `order_date` 列上的索引。你应该如何改写这个查询以进行优化？
    ```sql
    SELECT *
    FROM sales_orders
    WHERE DATE_FORMAT(order_date, '%Y-%m') = '2026-01';
    ```