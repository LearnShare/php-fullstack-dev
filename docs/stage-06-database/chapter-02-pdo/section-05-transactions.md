# 6.2.5 事务处理 (Transaction Handling)

## 概述

在许多业务场景中，我们需要执行一系列相互依赖的数据库操作，这些操作必须**作为一个整体**全部成功，或者在其中任何一步失败时全部撤销。例如，银行转账需要从一个账户扣款，并向另一个账户存款，这两个操作必须同时完成。如果只完成了扣款而存款失败，就会导致数据严重不一致。

**事务 (Transaction)** 就是为了解决这个问题而设计的。它是一个将一系列数据库操作捆绑成一个单一、不可分割的工作单元的机制。

本节将介绍事务的 ACID 属性，并详细讲解如何在 PDO 中使用事务来保证复杂操作的数据完整性。

## 为什么需要事务：银行转账的例子

假设 A 用户要向 B 用户转账 100 元。这个过程至少需要两个步骤：

1.  从 A 用户的账户余额中减去 100 元。
    `UPDATE accounts SET balance = balance - 100 WHERE user_id = 'A';`
2.  向 B 用户的账户余额中增加 100 元。
    `UPDATE accounts SET balance = balance + 100 WHERE user_id = 'B';`

现在，想象一下如果在执行完第一步之后，数据库服务器突然崩溃或断电。结果将是灾难性的：A 的钱被扣了，但 B 却没有收到。数据库的数据变得不一致。

事务通过确保这两个操作要么**都成功**，要么**都失败**（回滚到操作之前的状态），来防止这种情况的发生。

## ACID 属性

事务的可靠性由四个核心属性来保证，统称为 **ACID**：

1.  **原子性 (Atomicity)**
    -   **定义**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被**回滚 (Rollback)** 到事务开始前的状态，就像这个事务从来没有执行过一样。
    -   **例子**：银行转账的两个 `UPDATE` 操作是一个原子操作。

2.  **一致性 (Consistency)**
    -   **定义**：事务必须使数据库从一个一致的状态转移到另一个一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
    -   **例子**：假设有约束要求账户余额不能为负。如果转账会导致 A 账户余额变为负数，那么这个事务因为破坏了一致性而不应该被成功执行。

3.  **隔离性 (Isolation)**
    -   **定义**：当多个事务并发访问数据库时，一个事务的执行不应被其他事务干扰。即一个事务所做的修改在最终提交前，对其他事务是不可见的。
    -   **例子**：在 A 向 B 转账的过程中，另一个查询 C 账户余额的事务不应该看到 A 的钱少了而 B 的钱还没多的中间状态。

4.  **持久性 (Durability)**
    -   **定义**：一旦一个事务被提交 (Commit)，它对数据库中数据的改变就是永久性的，接下来的其他操作或故障不应该对其有任何影响。
    -   **例子**：一旦转账事务提示成功，即使系统立即崩溃，重启后转账的结果依然存在。

## 在 PDO 中使用事务

PDO 通过三个核心方法来控制事务：

-   `PDO::beginTransaction()`: **开始一个事务**。它会关闭数据库的“自动提交 (autocommit)”模式。在此之后的所有 SQL 操作都不会立即生效。
-   `PDO::commit()`: **提交事务**。将自 `beginTransaction()` 以来的所有操作永久性地应用到数据库中。
-   `PDO::rollBack()`: **回滚事务**。撤销自 `beginTransaction()` 以来的所有操作，使数据库恢复到事务开始前的状态。

### 正确的事务处理模式：`try...catch`

处理事务最安全、最健壮的方式，就是将其包裹在一个 `try...catch` 块中。这能确保在任何操作抛出异常（例如，违反约束、语法错误、连接中断）时，我们都有机会执行回滚。

**示例**：使用事务安全地实现银行转账。

```php
<?php
// ... $pdo 连接对象，并已设置为 PDO::ERRMODE_EXCEPTION 模式

// 两个参与转账的用户ID和金额
$fromUserId = 1; // 假设为用户 A
$toUserId = 2;   // 假设为用户 B
$amount = 100.00;

try {
    // 1. 开始事务
    $pdo->beginTransaction();

    // 准备 SQL 语句
    $stmtUpdate = $pdo->prepare("UPDATE accounts SET balance = balance - :amount WHERE user_id = :user_id");
    $stmtUpdate->execute([':amount' => $amount, ':user_id' => $fromUserId]);

    $stmtUpdate = $pdo->prepare("UPDATE accounts SET balance = balance + :amount WHERE user_id = :user_id");
    $stmtUpdate->execute([':amount' => $amount, ':user_id' => $toUserId]);

    // 可以在这里加入更多检查，例如检查 A 的余额是否足够
    // 如果不足，可以手动抛出异常来触发回滚： throw new \Exception("余额不足");

    // 2. 如果所有操作都成功，提交事务
    $pdo->commit();

    echo "转账成功！";

} catch (\PDOException | \Exception $e) {
    // 3. 如果在 try 块中有任何异常抛出，捕获它
    echo "转账失败: " . $e->getMessage();

    // 检查是否有活动的事务，然后回滚
    if ($pdo->inTransaction()) {
        $pdo->rollBack();
        echo " 事务已回滚。";
    }

    // 记录错误或做其他处理
}
```

**这个模式的工作流程**：
1.  代码进入 `try` 块，`beginTransaction()` 启动事务。
2.  两个 `UPDATE` 语句依次执行。
3.  **情况一（成功）**：所有语句都顺利执行，没有任何异常。代码执行到 `commit()`，所有更改被永久保存。
4.  **情况二（失败）**：任何一个 `execute()` 因为某种原因（如 `user_id` 不存在、数据库断开连接等）失败，并抛出 `PDOException`。程序的执行会立即跳转到 `catch` 块。`commit()` 永远不会被执行。
5.  在 `catch` 块中，`rollBack()` 被调用，数据库将撤销 `beginTransaction()` 之后的所有更改，两个账户的余额都将恢复到事务开始前的状态，保证了数据的一致性。

## 重要注意事项

1.  **存储引擎支持**
    -   并非所有的数据库存储引擎都支持事务。在 MySQL 中，**InnoDB** 和 **NDB** 引擎支持事务，而 **MyISAM** 和 **MEMORY** 等引擎则不支持。请确保你的表使用的是支持事务的存储引擎（InnoDB 是 MySQL 5.5+ 的默认引擎）。

2.  **DDL 语句**
    -   数据定义语言 (DDL) 语句，如 `CREATE TABLE`, `DROP TABLE`, `ALTER TABLE` 等，会导致事务被隐式地提交。你不能在事务中执行这些操作然后期望能够回滚它们。

3.  **检查事务状态**
    -   `$pdo->inTransaction()` 是一个有用的方法，用于检查当前 PDO 连接是否在一个活动的事务中。在 `catch` 块中执行 `rollBack()` 之前，使用它来判断是一个好习惯。

---

## 练习任务

1.  **检查引擎**：
    登录到你的 MySQL 客户端，使用 `SHOW CREATE TABLE your_table_name;` 命令检查你之前创建的 `users` 和 `accounts` 表，确认它们的 `ENGINE`（存储引擎）是什么。如果不是 InnoDB，请查阅资料了解如何将其修改为 InnoDB。

2.  **实现商品下单逻辑**：
    模拟一个简化的下单流程，它包含两个步骤：
    1.  在 `products` 表中将指定商品的库存 (`stock`) 减去购买的数量。
    2.  在 `orders` 表中插入一条新的订单记录。
    请将这两个操作包裹在一个事务中。你需要考虑如果库存不足，应该如何处理（提示：可以在程序中检查库存，或者依赖数据库的 `CHECK` 约束，并捕获异常），确保在库存不足时，订单记录不会被创建。

3.  **测试回滚**：
    在练习2的事务代码中，在第一个 `UPDATE` 语句之后，第二个 `INSERT` 语句之前，故意制造一个 SQL 语法错误（例如，`INSERT INTO orders_oops ...`），然后执行脚本。观察程序的输出，并检查数据库中的 `products` 表，确认库存是否被错误地扣减了。
